#include <filesystem>
#include <string>

const std::string PATH_ROOT = "/tmp/sfifo";
constexpr int ARG_MAX = 2097152;

int sfifo_mkfifo(std::string, std::string);
std::fstream sfifo_fstream(std::string, std::string);
int sfifo_open(std::string, std::string);
#include "common.h"

#include <string>
#include <cerrno>
#include <cstdlib>
#include <cstdio>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <cstdio>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <fcntl.h>
#include <unistd.h>
#include <iostream>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>

int sfifo_mkfifo(std::string path_root, std::string filename) {
    std::filesystem::path path = path_root / std::filesystem::path(filename);
    std::error_code err;
    int ret;

    if (std::filesystem::exists(path)) {
        if (!std::filesystem::is_fifo(path)) {
            std::cout << "ERROR: File " << path << " exists and is NOT a FIFO pipe" << std::endl;
            exit(1);
        } else {
            // TODO: check with sudo
            if (!std::filesystem::remove(path, err)) {
                std::cout << err << std::endl << path \
                    << " exists, failure when attempting to remove and recreate" << std::endl;
                exit(1);
            }
        }
    }
    if ((ret = mkfifo(path.c_str(), 0660))) {
        std::perror("mkfifo");
        exit(ret);
    }
    return 0;
}

int sfifo_open(std::string path_root, std::string filename)
{
    std::filesystem::path path = path_root / std::filesystem::path(filename);
    int fd;

    // TODO: err handling where used
    return open(path.c_str(), O_RDWR | O_TRUNC | O_NONBLOCK);
}

std::fstream sfifo_fstream(std::string path_root, std::string filename) {
    std::filesystem::path path = path_root / std::filesystem::path(filename);

    std::fstream fifo(path.c_str());
    if (!fifo.is_open()) {
        std::cout << "Failed to open fifo fstream at " << path <<std::endl;
        exit(1);
    }
    return fifo;
}

#include "sfifo.h"

#include <poll.h>

#include <string>
#include <fstream>
#include <iostream>
#include <csignal>
#include <cmath>

volatile sig_atomic_t interrupted = 0;
static int srv_fd = -1;

constexpr int PID_MAX {4194304};
const int PID_MAX_SLEN = (int)log10(abs(PID_MAX)) + 1;

void handle_signal(int sig)
{
    interrupted = 1;
    std::string sig_name = (sig == SIGINT) ? "SIGINT" : "SIGTERM";
    int exit_code = (sig == SIGINT) ? 0 : 1;
    std::cout << "Caught " << sig_name << ", performing cleanup and exiting...";
    if (srv_fd != -1)
        close(srv_fd);
    exit(exit_code);
}

int main()
{
    std::error_code ec;
    std::filesystem::create_directory(PATH_ROOT, ec);
    if (ec && !std::filesystem::exists(PATH_ROOT)) {
        std::cout << "Error creating " << PATH_ROOT << ec.message() << '\n';
        exit(1);
    }
    std::signal(SIGINT, handle_signal);
    std::signal(SIGTERM, handle_signal);

    sfifo_mkfifo(PATH_ROOT, "srv");
    srv_fd = sfifo_open(PATH_ROOT, "srv");
    if (srv_fd == -1) {
        perror("open");
        exit(1);
    }
    FILE* fp = fdopen(srv_fd, "r");

    struct pollfd pfd;
    pfd.fd = srv_fd;
    pfd.events = POLLIN;

    while (!interrupted) {
        bool erratic_write_detected = false;
        int ret = poll(&pfd, 1, -1);
        if (ret == -1) {
            perror("poll");
            exit(1);
        }

        int c = 0, cc = 0;
        std::string pid;
        do {
            pid.append(1, c);
            if (++cc >= PID_MAX_SLEN) {
                std::cout << "Ingoring erratic write - PID to long..." << std::endl;
                erratic_write_detected = true;
            }
        } while ((c = getc(fp)) != '\0' && !interrupted && !erratic_write_detected);
        if (erratic_write_detected)
            continue;

        cc = 0;
        while ((c = getc(fp)) != '\0' && !interrupted && !erratic_write_detected) {
            if (++cc > ARG_MAX) {
                std::cout << "Ingoring erratic write - message to long..." << std::endl;
                erratic_write_detected = true;
            }
        }
        if (erratic_write_detected)
            continue;

        std::fstream cli = sfifo_fstream(PATH_ROOT, pid);
        // TODO: -1?
        cli << (cc - 1) << std::endl;
    }
}
#include "sfifo.h"

#include <unistd.h>

#include <string>
#include <fstream>
#include <iostream>

int main(void)
{
    std::string line;
    std::cout << ">> Enter your message in one line, press ENTER when done." << std::endl;
    while (1) {
        getline(std::cin, line);
        if (line.length() <= ARG_MAX)
            break;
        std::cout << "Message exceeding " << ARG_MAX << ", try again." << std::endl;
    }
    std::filesystem::path pid = std::to_string(getpid());
    std::string payload = pid.string() + '\0' + line + '\0';

    int srv_fd = sfifo_open(PATH_ROOT, "srv");
    if (srv_fd == -1) {
        perror("open");
        exit(1);
    }
    int sz;
    if ((sz = write(srv_fd, payload.data(), payload.size()) < -1)) {
        perror("write");
        exit(1);
    }
    std::cout << ">> Sent!" << std::endl;

    sfifo_mkfifo(PATH_ROOT, pid);
    std::string char_count;
    std::fstream cli = sfifo_fstream(PATH_ROOT, pid);
    usleep(10000);
    cli >> char_count;
    std::cout << "Char count: " << char_count << std::endl;
    cli.close();
    close(srv_fd);
    return 0;
}
#include <filesystem>
#include <string>

const std::string PATH_ROOT = "/tmp/sfifo";
constexpr int ARG_MAX = 2097152;

int sfifo_mkfifo(std::string, std::string);
std::fstream sfifo_fstream(std::string, std::string);
int sfifo_open(std::string, std::string);
#include "sfifo.h"

#include <sys/stat.h>
#include <fcntl.h>

#include <string>
#include <fstream>
#include <iostream>

int sfifo_mkfifo(std::string path_root, std::string filename) {
    std::filesystem::path path = path_root / std::filesystem::path(filename);
    std::error_code err;
    int ret;

    if (std::filesystem::exists(path)) {
        if (!std::filesystem::is_fifo(path)) {
            std::cout << "ERROR: File " << path << " exists and is NOT a FIFO pipe" << std::endl;
            exit(1);
        } else {
            // TODO: check with sudo
            if (!std::filesystem::remove(path, err)) {
                std::cout << err << std::endl << path \
                    << " exists, failure when attempting to remove and recreate" << std::endl;
                exit(1);
            }
        }
    }
    if ((ret = mkfifo(path.c_str(), 0660))) {
        std::perror("mkfifo");
        exit(ret);
    }
    return 0;
}

int sfifo_open(std::string path_root, std::string filename)
{
    std::filesystem::path path = path_root / std::filesystem::path(filename);
    // TODO: err handling where used
    return open(path.c_str(), O_RDWR | O_TRUNC | O_NONBLOCK);
}

std::fstream sfifo_fstream(std::string path_root, std::string filename) {
    std::filesystem::path path = path_root / std::filesystem::path(filename);

    std::fstream fifo(path.c_str());
    if (!fifo.is_open()) {
        std::cout << "Failed to open fifo fstream at " << path <<std::endl;
        exit(1);
    }
    return fifo;
}

#include "sfifo.h"

#include <poll.h>

#include <string>
#include <fstream>
#include <iostream>
#include <csignal>
#include <cmath>

volatile sig_atomic_t interrupted = 0;
static int srv_fd = -1;

constexpr int PID_MAX {4194304};
const int PID_MAX_SLEN = (int)log10(abs(PID_MAX)) + 1;
const std::filesystem::path srv_fn = "srv";

void cleanup(int sig)
{
    interrupted = 1;
    std::string sig_name = (sig == SIGINT) ? "SIGINT" : "SIGTERM";
    int exit_code = (sig == SIGINT) ? 0 : 1;
    std::cout << "Caught " << sig_name << ", performing cleanup and exiting...";
    if (srv_fd != -1)
        close(srv_fd);

    if (!std::filesystem::remove(PATH_ROOT / srv_fn))
        perror("remove");
    exit(exit_code);
}

int main()
{
    int d = 0;
    std::error_code ec;
    std::filesystem::create_directory(PATH_ROOT, ec);
    if (ec && !std::filesystem::exists(PATH_ROOT)) {
        std::cout << "Error creating " << PATH_ROOT << ec.message() << '\n';
        exit(1);
    }
    std::signal(SIGINT, cleanup);
    std::signal(SIGTERM, cleanup);

    sfifo_mkfifo(PATH_ROOT, srv_fn);
    srv_fd = sfifo_open(PATH_ROOT, srv_fn);
    if (srv_fd == -1) {
        perror("open");
        exit(1);
    }
    FILE* fp = fdopen(srv_fd, "r");

    struct pollfd pfd;
    pfd.fd = srv_fd;
    pfd.events = POLLIN;

    while (!interrupted) {
        bool erratic_write_detected = false;
        int ret = poll(&pfd, 1, -1);
        if (ret == -1) {
            perror("poll");
            exit(1);
        }

        int c = 0, cc = 0;
        std::string pid;
        do {
            pid.append(1, c);
            if (++cc >= PID_MAX_SLEN) {
                std::cout << "Ingoring erratic write - PID to long..." << std::endl;
                erratic_write_detected = true;
            }
        } while ((c = getc(fp)) != '\0' && !interrupted && !erratic_write_detected);
        if (erratic_write_detected)
            continue;

        cc = 0;
        while ((c = getc(fp)) != '\0' && !interrupted && !erratic_write_detected) {
            if (++cc > ARG_MAX) {
                std::cout << "Ingoring erratic write - message to long..." << std::endl;
                erratic_write_detected = true;
            }
        }
        if (erratic_write_detected)
            continue;

        std::fstream cli = sfifo_fstream(PATH_ROOT, pid);
        // TODO: -1?
        std::cout << ++d << std::endl;
        cli << (cc - 1) << std::endl;
        std::cout << ++d << std::endl;
    }
}
#include "sfifo.h"

#include <unistd.h>

#include <string>
#include <fstream>
#include <iostream>

int main(void)
{
    std::string line;
    std::cout << ">> Enter your message in one line, press ENTER when done." << std::endl;
    while (1) {
        getline(std::cin, line);
        if (line.length() <= ARG_MAX)
            break;
        std::cout << "Message exceeding " << ARG_MAX << ", try again." << std::endl;
    }
    std::filesystem::path pid = std::to_string(getpid());
    std::cout << line << std::endl; // TODO: temp
    std::string payload = pid.string() + '\0' + line + '\0';

    int srv_fd = sfifo_open(PATH_ROOT, "srv");
    if (srv_fd == -1) {
        perror("open");
        exit(1);
    }
    int sz;
    if ((sz = write(srv_fd, payload.data(), payload.size()) < -1)) {
        perror("write");
        exit(1);
    }
    std::cout << ">> Sent!" << std::endl;

    sfifo_mkfifo(PATH_ROOT, pid);
    std::fstream cli = sfifo_fstream(PATH_ROOT, pid);
    std::string char_count;
    cli >> char_count;
    std::cout << "Char count: " << char_count << std::endl;
    cli.close();
    close(srv_fd);
    return 0;
}
#include <filesystem>
#include <string>

const std::string PATH_ROOT = "/tmp/sfifo";
constexpr int ARG_MAX = 2097152;

int sfifo_mkfifo(std::string, std::string);
std::fstream sfifo_fstream(std::string, std::string);
int sfifo_open(std::string, std::string);
#include "sfifo.h"

#include <sys/stat.h>
#include <fcntl.h>

#include <string>
#include <fstream>
#include <iostream>

int sfifo_mkfifo(std::string path_root, std::string filename) {
    std::filesystem::path path = path_root / std::filesystem::path(filename);
    std::error_code err;
    int ret;

    if (std::filesystem::exists(path)) {
        if (!std::filesystem::is_fifo(path)) {
            std::cout << "ERROR: File " << path << " exists and is NOT a FIFO pipe" << std::endl;
            exit(1);
        } else {
            // TODO: check with sudo
            if (!std::filesystem::remove(path, err)) {
                std::cout << err << std::endl << path \
                    << " exists, failure when attempting to remove and recreate" << std::endl;
                exit(1);
            }
        }
    }
    if ((ret = mkfifo(path.c_str(), 0660))) {
        std::perror("mkfifo");
        exit(ret);
    }
    return 0;
}

int sfifo_open(std::string path_root, std::string filename)
{
    std::filesystem::path path = path_root / std::filesystem::path(filename);
    // TODO: err handling where used
    return open(path.c_str(), O_RDWR | O_TRUNC | O_NONBLOCK);
}

std::fstream sfifo_fstream(std::string path_root, std::string filename) {
    std::filesystem::path path = path_root / std::filesystem::path(filename);

    std::fstream fifo(path.c_str());
    if (!fifo.is_open()) {
        std::cout << "Failed to open fifo fstream at " << path <<std::endl;
        exit(1);
    }
    return fifo;
}

#include "sfifo.h"

#include <poll.h>

#include <string>
#include <fstream>
#include <iostream>
#include <csignal>
#include <cmath>

volatile sig_atomic_t interrupted = 0;
static int srv_fd = -1;

constexpr int PID_MAX {4194304};
const int PID_MAX_SLEN = (int)log10(abs(PID_MAX)) + 1;
const std::filesystem::path srv_fn = "srv";

void cleanup(int sig)
{
    interrupted = 1;
    std::string sig_name = (sig == SIGINT) ? "SIGINT" : "SIGTERM";
    int exit_code = (sig == SIGINT) ? 0 : 1;
    std::cout << "Caught " << sig_name << ", performing cleanup and exiting...";
    if (srv_fd != -1)
        close(srv_fd);

    if (!std::filesystem::remove(PATH_ROOT / srv_fn))
        perror("remove");
    exit(exit_code);
}

int main()
{
    int d = 0;
    std::error_code ec;
    std::filesystem::create_directory(PATH_ROOT, ec);
    if (ec && !std::filesystem::exists(PATH_ROOT)) {
        std::cout << "Error creating " << PATH_ROOT << ec.message() << '\n';
        exit(1);
    }
    std::signal(SIGINT, cleanup);
    std::signal(SIGTERM, cleanup);

    sfifo_mkfifo(PATH_ROOT, srv_fn);
    srv_fd = sfifo_open(PATH_ROOT, srv_fn);
    if (srv_fd == -1) {
        perror("open");
        exit(1);
    }
    FILE* fp = fdopen(srv_fd, "r");

    struct pollfd pfd;
    pfd.fd = srv_fd;
    pfd.events = POLLIN;

    while (!interrupted) {
        bool erratic_write_detected = false;
        int ret = poll(&pfd, 1, -1);
        if (ret == -1) {
            perror("poll");
            exit(1);
        }

        int c = 0, cc = 0;
        std::string pid;
        do {
            pid.append(1, c);
            if (++cc >= PID_MAX_SLEN) {
                std::cout << "Ingoring erratic write - PID to long..." << std::endl;
                erratic_write_detected = true;
            }
        } while ((c = getc(fp)) != '\0' && !interrupted && !erratic_write_detected);
        if (erratic_write_detected)
            continue;

        cc = 0;
        while ((c = getc(fp)) != '\0' && !interrupted && !erratic_write_detected) {
            if (++cc > ARG_MAX) {
                std::cout << "Ingoring erratic write - message to long..." << std::endl;
                erratic_write_detected = true;
            }
        }
        if (erratic_write_detected)
            continue;

        std::fstream cli = sfifo_fstream(PATH_ROOT, pid);
        cli << cc << std::endl;
    }
}
#include "sfifo.h"

#include <unistd.h>

#include <string>
#include <fstream>
#include <iostream>

int main(void)
{
    std::string line;
    std::cout << ">> Enter your message in one line, press ENTER when done." << std::endl;
    while (1) {
        getline(std::cin, line);
        if (line.length() <= ARG_MAX)
            break;
        std::cout << "Message exceeding " << ARG_MAX << ", try again." << std::endl;
    }
    std::filesystem::path pid = std::to_string(getpid());
    std::cout << line << std::endl; // TODO: temp
    std::string payload = pid.string() + '\0' + line + '\0';

    int srv_fd = sfifo_open(PATH_ROOT, "srv");
    if (srv_fd == -1) {
        perror("open");
        exit(1);
    }
    int sz;
    sfifo_mkfifo(PATH_ROOT, pid);
    if ((sz = write(srv_fd, payload.data(), payload.size()) < -1)) {
        perror("write");
        exit(1);
    }
    std::cout << ">> Sent!" << std::endl;

    std::fstream cli = sfifo_fstream(PATH_ROOT, pid);
    std::string char_count;
    cli >> char_count;
    std::cout << "Char count: " << char_count << std::endl;
    // cli.close();
    close(srv_fd);
    return 0;
}
#include <filesystem>
#include <string>

const std::string PATH_ROOT = "/tmp/sfifo";
constexpr int ARG_MAX = 2097152;

int sfifo_mkfifo(std::string, std::string);
std::fstream sfifo_fstream(std::string, std::string, int);
int sfifo_open(std::string, std::string);
#include "sfifo.h"

#include <sys/stat.h>
#include <fcntl.h>

#include <string>
#include <fstream>
#include <iostream>

int sfifo_mkfifo(std::string path_root, std::string filename) {
    std::filesystem::path path = path_root / std::filesystem::path(filename);
    std::error_code err;
    int ret;

    if (std::filesystem::exists(path)) {
        if (!std::filesystem::is_fifo(path)) {
            std::cout << "ERROR: File " << path << " exists and is NOT a FIFO pipe" << std::endl;
            exit(1);
        } else {
            // TODO: check with sudo
            if (!std::filesystem::remove(path, err)) {
                std::cout << err << std::endl << path \
                    << " exists, failure when attempting to remove and recreate" << std::endl;
                exit(1);
            }
        }
    }
    if ((ret = mkfifo(path.c_str(), 0660))) {
        std::perror("mkfifo");
        exit(ret);
    }
    return 0;
}

int sfifo_open(std::string path_root, std::string filename)
{
    std::filesystem::path path = path_root / std::filesystem::path(filename);
    // TODO: err handling where used
    return open(path.c_str(), O_RDWR | O_TRUNC | O_NONBLOCK);
}

std::fstream sfifo_fstream(std::string path_root, std::string filename, int mode) {
    std::filesystem::path path = path_root / std::filesystem::path(filename);

    std::fstream fifo(path.c_str(), mode ? std::ios::in : std::ios::out);
    if (!fifo.is_open()) {
        std::cout << "Failed to open fifo fstream at " << path <<std::endl;
        exit(1);
    }
    return fifo;
}

#include "sfifo.h"

#include <poll.h>

#include <string>
#include <fstream>
#include <iostream>
#include <csignal>
#include <cmath>

volatile sig_atomic_t interrupted = 0;
static int srv_fd = -1;

constexpr int PID_MAX {4194304};
const int PID_MAX_SLEN = (int)log10(abs(PID_MAX)) + 1;
const std::filesystem::path srv_fn = "srv";

void cleanup(int sig)
{
    interrupted = 1;
    std::string sig_name = (sig == SIGINT) ? "SIGINT" : "SIGTERM";
    int exit_code = (sig == SIGINT) ? 0 : 1;
    std::cout << "Caught " << sig_name << ", performing cleanup and exiting...";
    if (srv_fd != -1)
        close(srv_fd);

    if (!std::filesystem::remove(PATH_ROOT / srv_fn))
        perror("remove");
    exit(exit_code);
}

int main()
{
    int d = 0;
    std::error_code ec;
    std::filesystem::create_directory(PATH_ROOT, ec);
    if (ec && !std::filesystem::exists(PATH_ROOT)) {
        std::cout << "Error creating " << PATH_ROOT << ec.message() << '\n';
        exit(1);
    }
    std::signal(SIGINT, cleanup);
    std::signal(SIGTERM, cleanup);

    sfifo_mkfifo(PATH_ROOT, srv_fn);
    srv_fd = sfifo_open(PATH_ROOT, srv_fn);
    if (srv_fd == -1) {
        perror("open");
        exit(1);
    }
    FILE* fp = fdopen(srv_fd, "r");

    struct pollfd pfd;
    pfd.fd = srv_fd;
    pfd.events = POLLIN;

    while (!interrupted) {
        std::cout << ++d << std::endl;
        bool erratic_write_detected = false;
        int ret = poll(&pfd, 1, -1);
        if (ret == -1) {
            perror("poll");
            exit(1);
        }

        int c = 0, cc = 0;
        std::string pid;
        do {
            pid.append(1, c);
            if (++cc >= PID_MAX_SLEN) {
                std::cout << "Ingoring erratic write - PID to long..." << std::endl;
                erratic_write_detected = true;
            }
        } while ((c = getc(fp)) != '\0' && !interrupted && !erratic_write_detected);
        if (erratic_write_detected)
            continue;

        cc = 0;
        while ((c = getc(fp)) != '\0' && !interrupted && !erratic_write_detected) {
            if (++cc > ARG_MAX) {
                std::cout << "Ingoring erratic write - message to long..." << std::endl;
                erratic_write_detected = true;
            }
        }
        if (erratic_write_detected)
            continue;

        std::fstream cli = sfifo_fstream(PATH_ROOT, pid, 1);
        std::cout << ++d << std::endl;
        cli << cc << std::endl;
        cli.close();
    }
}
#include "sfifo.h"

#include <unistd.h>

#include <string>
#include <fstream>
#include <iostream>

int main(void)
{
    std::string line;
    std::cout << ">> Enter your message in one line, press ENTER when done." << std::endl;
    while (1) {
        getline(std::cin, line);
        if (line.length() <= ARG_MAX)
            break;
        std::cout << "Message exceeding " << ARG_MAX << ", try again." << std::endl;
    }
    std::filesystem::path pid = std::to_string(getpid());
    std::cout << line << std::endl; // TODO: temp
    std::string payload = pid.string() + '\0' + line + '\0';

    int srv_fd = sfifo_open(PATH_ROOT, "srv");
    if (srv_fd == -1) {
        perror("open");
        exit(1);
    }
    int sz;
    sfifo_mkfifo(PATH_ROOT, pid);
    if ((sz = write(srv_fd, payload.data(), payload.size()) < -1)) {
        perror("write");
        exit(1);
    }
    std::cout << ">> Sent!" << std::endl;

    std::fstream cli = sfifo_fstream(PATH_ROOT, pid, 0);
    std::string char_count;
    cli >> char_count;
    std::cout << "Char count: " << char_count << std::endl;
    cli.close();
    close(srv_fd);
    return 0;
}
